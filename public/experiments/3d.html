<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js - 3D Text with Canvas Texture</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
        }

        #info a {
            color: #f00;
            text-decoration: none;
        }
    </style>
</head>
<body>

    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - 3D Text with Canvas Texture<br/>
        <label for="textureSelect">Texture: </label>
        <select id="textureSelect" style="padding: 5px; margin-top: 10px;">
            <option value="stripes">Stripe Test</option>
            <option value="neon">Neon Glow</option>
            <option value="carbon">Carbon Fiber</option>
            <option value="galaxy">Galaxy/Space</option>
            <option value="lava">Lava</option>
            <option value="matrix">Matrix Rain</option>
            <option value="holographic">Holographic</option>
            <option value="circuit">Circuit Board</option>
            <option value="marble">Marble</option>
        </select>
        <br/><br/>
        <div style="background: rgba(0,0,0,0.7); padding: 15px; display: inline-block; text-align: left;">
            <div style="margin: 5px 0;">
                <label for="size">Size: <span id="sizeValue">12</span></label><br/>
                <input id="size" type="range" min="5" max="30" value="12" step="1" style="width: 200px">
            </div>
            <div style="margin: 5px 0;">
                <label for="depth">Depth: <span id="depthValue">4</span></label><br/>
                <input id="depth" type="range" min="0.5" max="10" value="4" step="0.5" style="width: 200px">
            </div>
            <div style="margin: 5px 0;">
                <label for="curveSegments">Curve Segments: <span id="curveSegmentsValue">12</span></label><br/>
                <input id="curveSegments" type="range" min="1" max="50" value="12" step="1" style="width: 200px">
            </div>
            <div style="margin: 5px 0;">
                <label for="bevelThickness">Bevel Thickness: <span id="bevelThicknessValue">0.5</span></label><br/>
                <input id="bevelThickness" type="range" min="0" max="3" value="0.5" step="0.1" style="width: 200px">
            </div>
            <div style="margin: 5px 0;">
                <label for="bevelSize">Bevel Size: <span id="bevelSizeValue">0.3</span></label><br/>
                <input id="bevelSize" type="range" min="0" max="3" value="0.3" step="0.1" style="width: 200px">
            </div>
            <div style="margin: 5px 0;">
                <label for="bevelSegments">Bevel Segments: <span id="bevelSegmentsValue">5</span></label><br/>
                <input id="bevelSegments" type="range" min="1" max="20" value="5" step="1" style="width: 200px">
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';

        let renderer, scene, camera, controls;
        let textMesh;

        init();

        function init() {
            // Camera setup
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;
            camera.position.y = 20;

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            // Create canvas for textures
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 512;

            let currentTexture;

            // Texture generation functions
            function createNeonTexture() {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Neon glow effect
                for (let i = 0; i < 5; i++) {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.8 - i * 0.15})`;
                    ctx.lineWidth = 20 - i * 3;
                    ctx.strokeRect(20 + i * 10, 20 + i * 10, canvas.width - 40 - i * 20, canvas.height - 40 - i * 20);
                }

                // Add some neon lines
                ctx.strokeStyle = 'rgba(255, 0, 255, 0.8)';
                ctx.lineWidth = 3;
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(Math.random() * canvas.width, Math.random() * canvas.height);
                    ctx.lineTo(Math.random() * canvas.width, Math.random() * canvas.height);
                    ctx.stroke();
                }

                // Bright center
                const glow = ctx.createRadialGradient(256, 256, 0, 256, 256, 200);
                glow.addColorStop(0, 'rgba(0, 255, 255, 0.3)');
                glow.addColorStop(1, 'rgba(0, 255, 255, 0)');
                ctx.fillStyle = glow;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            function createCarbonFiberTexture() {
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Create diagonal weave pattern
                const weaveSize = 20;
                for (let x = -canvas.height; x < canvas.width; x += weaveSize * 2) {
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(x, 0, weaveSize, canvas.height);
                    
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(x + weaveSize, 0, weaveSize, canvas.height);
                }

                // Add some shine
                ctx.save();
                ctx.globalAlpha = 0.1;
                for (let i = 0; i < 50; i++) {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 2, 2);
                }
                ctx.restore();
            }

            function createGalaxyTexture() {
                const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 400);
                gradient.addColorStop(0, '#4a148c');
                gradient.addColorStop(0.5, '#1a237e');
                gradient.addColorStop(1, '#000000');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Stars
                for (let i = 0; i < 200; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const size = Math.random() * 2;
                    ctx.fillStyle = `rgba(255, 255, 255, ${Math.random()})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Nebula clouds
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const nebula = ctx.createRadialGradient(x, y, 0, x, y, 100);
                    const colors = ['rgba(138, 43, 226, 0.3)', 'rgba(75, 0, 130, 0.3)', 'rgba(255, 20, 147, 0.3)'];
                    nebula.addColorStop(0, colors[i % colors.length]);
                    nebula.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = nebula;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }

            function createLavaTexture() {
                ctx.fillStyle = '#1a0a00';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Create cracks
                ctx.strokeStyle = '#ff4500';
                ctx.lineWidth = 3;
                
                for (let i = 0; i < 30; i++) {
                    ctx.beginPath();
                    let x = Math.random() * canvas.width;
                    let y = Math.random() * canvas.height;
                    ctx.moveTo(x, y);
                    
                    for (let j = 0; j < 5; j++) {
                        x += (Math.random() - 0.5) * 100;
                        y += (Math.random() - 0.5) * 100;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                // Add glow to cracks
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff6600';
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < 30; i++) {
                    ctx.beginPath();
                    let x = Math.random() * canvas.width;
                    let y = Math.random() * canvas.height;
                    ctx.moveTo(x, y);
                    
                    for (let j = 0; j < 5; j++) {
                        x += (Math.random() - 0.5) * 100;
                        y += (Math.random() - 0.5) * 100;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;

                // Hot spots
                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const hot = ctx.createRadialGradient(x, y, 0, x, y, 50);
                    hot.addColorStop(0, 'rgba(255, 255, 0, 0.6)');
                    hot.addColorStop(0.5, 'rgba(255, 100, 0, 0.4)');
                    hot.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = hot;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }

            function createMatrixTexture() {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Matrix characters
                const chars = 'ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ0123456789';
                ctx.font = '20px monospace';
                
                for (let x = 0; x < canvas.width; x += 25) {
                    for (let y = 0; y < canvas.height; y += 25) {
                        const char = chars[Math.floor(Math.random() * chars.length)];
                        const alpha = Math.random();
                        ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;
                        ctx.fillText(char, x, y);
                    }
                }

                // Bright falling columns
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * canvas.width;
                    const column = ctx.createLinearGradient(x, 0, x, canvas.height);
                    column.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    column.addColorStop(0.1, 'rgba(0, 255, 0, 0.8)');
                    column.addColorStop(1, 'rgba(0, 255, 0, 0)');
                    ctx.fillStyle = column;
                    ctx.fillRect(x - 2, 0, 4, canvas.height);
                }
            }

            function createHolographicTexture() {
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#ff0080');
                gradient.addColorStop(0.2, '#ff8c00');
                gradient.addColorStop(0.4, '#ffff00');
                gradient.addColorStop(0.6, '#00ff00');
                gradient.addColorStop(0.8, '#0080ff');
                gradient.addColorStop(1, '#8000ff');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Add interference patterns
                ctx.globalCompositeOperation = 'overlay';
                for (let i = 0; i < canvas.height; i += 3) {
                    ctx.fillStyle = i % 6 === 0 ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, i, canvas.width, 1);
                }

                // Diagonal lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                for (let i = -canvas.height; i < canvas.width; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i + canvas.height, canvas.height);
                    ctx.stroke();
                }
                ctx.globalCompositeOperation = 'source-over';
            }

            function createCircuitBoardTexture() {
                ctx.fillStyle = '#004d00';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Circuit traces
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                
                for (let i = 0; i < 20; i++) {
                    ctx.beginPath();
                    let x = Math.random() * canvas.width;
                    let y = Math.random() * canvas.height;
                    ctx.moveTo(x, y);
                    
                    for (let j = 0; j < 5; j++) {
                        const dir = Math.floor(Math.random() * 4);
                        const len = 30 + Math.random() * 50;
                        if (dir === 0) x += len;
                        else if (dir === 1) x -= len;
                        else if (dir === 2) y += len;
                        else y -= len;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                // Solder pads
                ctx.fillStyle = '#ffd700';
                for (let i = 0; i < 50; i++) {
                    ctx.beginPath();
                    ctx.arc(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        3 + Math.random() * 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }

                // Components
                ctx.fillStyle = '#333333';
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 1;
                for (let i = 0; i < 15; i++) {
                    const x = Math.random() * (canvas.width - 40);
                    const y = Math.random() * (canvas.height - 20);
                    ctx.fillRect(x, y, 30 + Math.random() * 20, 15 + Math.random() * 10);
                    ctx.strokeRect(x, y, 30 + Math.random() * 20, 15 + Math.random() * 10);
                }
            }

            function createMarbleTexture() {
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#f0f0f0');
                gradient.addColorStop(0.5, '#e0e0e0');
                gradient.addColorStop(1, '#d0d0d0');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Marble veins
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                ctx.lineWidth = 2;
                
                for (let i = 0; i < 30; i++) {
                    ctx.beginPath();
                    let x = Math.random() * canvas.width;
                    let y = Math.random() * canvas.height;
                    ctx.moveTo(x, y);
                    
                    for (let j = 0; j < 10; j++) {
                        x += (Math.random() - 0.5) * 80;
                        y += (Math.random() - 0.5) * 80;
                        ctx.quadraticCurveTo(
                            x + (Math.random() - 0.5) * 50,
                            y + (Math.random() - 0.5) * 50,
                            x, y
                        );
                    }
                    ctx.stroke();
                }

                // Darker veins
                ctx.strokeStyle = 'rgba(80, 80, 80, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 20; i++) {
                    ctx.beginPath();
                    let x = Math.random() * canvas.width;
                    let y = Math.random() * canvas.height;
                    ctx.moveTo(x, y);
                    
                    for (let j = 0; j < 8; j++) {
                        x += (Math.random() - 0.5) * 60;
                        y += (Math.random() - 0.5) * 60;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
            }

            function createStripeTestTexture() {
                // Simple bold vertical stripes to test UV mapping
                for (let i = 0; i < 8; i++) {
                    ctx.fillStyle = i % 2 === 0 ? '#ff0000' : '#00ff00';
                    ctx.fillRect(i * 64, 0, 64, canvas.height);
                }
                
                // Add horizontal stripes on top
                ctx.globalAlpha = 0.5;
                for (let i = 0; i < 8; i++) {
                    ctx.fillStyle = i % 2 === 0 ? '#0000ff' : '#ffff00';
                    ctx.fillRect(0, i * 64, canvas.width, 64);
                }
                ctx.globalAlpha = 1.0;
            }

            function updateTexture(type) {
                switch(type) {
                    case 'neon': createNeonTexture(); break;
                    case 'carbon': createCarbonFiberTexture(); break;
                    case 'galaxy': createGalaxyTexture(); break;
                    case 'lava': createLavaTexture(); break;
                    case 'matrix': createMatrixTexture(); break;
                    case 'holographic': createHolographicTexture(); break;
                    case 'circuit': createCircuitBoardTexture(); break;
                    case 'marble': createMarbleTexture(); break;
                    case 'stripes': createStripeTestTexture(); break;
                }

                if (currentTexture) {
                    currentTexture.needsUpdate = true;
                }
            }

            // Create initial texture
            currentTexture = new THREE.CanvasTexture(canvas);
            currentTexture.colorSpace = THREE.SRGBColorSpace;
            currentTexture.wrapS = THREE.RepeatWrapping;
            currentTexture.wrapT = THREE.RepeatWrapping;
            // Scale down the texture repeat to make patterns larger
            currentTexture.repeat.set(0.05, 0.05);
            updateTexture('stripes');

            // Setup texture selector
            const textureSelect = document.getElementById('textureSelect');
            textureSelect.addEventListener('change', function() {
                updateTexture(this.value);
            });

            // Load font and create 3D text
            let loadedFont;
            const loader = new FontLoader();
            loader.load('https://cdn.jsdelivr.net/npm/three@0.170.0/examples/fonts/helvetiker_bold.typeface.json', function(font) {
                loadedFont = font;
                createText();
                setupSliders();
            });

            function createText() {
                // Remove old text if it exists
                if (textMesh) {
                    scene.remove(textMesh);
                    textMesh.geometry.dispose();
                }

                const size = parseFloat(document.getElementById('size').value);
                const depth = parseFloat(document.getElementById('depth').value);
                const curveSegments = parseInt(document.getElementById('curveSegments').value);
                const bevelThickness = parseFloat(document.getElementById('bevelThickness').value);
                const bevelSize = parseFloat(document.getElementById('bevelSize').value);
                const bevelSegments = parseInt(document.getElementById('bevelSegments').value);

                const textGeometry = new TextGeometry('Hello World!', {
                    font: loadedFont,
                    size: size,
                    depth: depth,
                    curveSegments: curveSegments,
                    bevelEnabled: true,
                    bevelThickness: bevelThickness,
                    bevelSize: bevelSize,
                    bevelOffset: 0,
                    bevelSegments: bevelSegments
                });

                textGeometry.center();

                const textMaterial = new THREE.MeshStandardMaterial({
                    map: currentTexture,
                    roughness: 0.3,
                    metalness: 0.2
                });

                textMesh = new THREE.Mesh(textGeometry, textMaterial);
                scene.add(textMesh);
            }

            function setupSliders() {
                const sliders = ['size', 'depth', 'curveSegments', 'bevelThickness', 'bevelSize', 'bevelSegments'];
                
                sliders.forEach(id => {
                    const slider = document.getElementById(id);
                    const valueDisplay = document.getElementById(id + 'Value');
                    
                    slider.addEventListener('input', function() {
                        valueDisplay.textContent = this.value;
                        createText();
                    });
                });
            }

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xff00ff, 1, 100);
            pointLight.position.set(-10, 10, 10);
            scene.add(pointLight);

            const pointLight2 = new THREE.PointLight(0x00ffff, 1, 100);
            pointLight2.position.set(10, -10, 10);
            scene.add(pointLight2);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            controls.update();

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>