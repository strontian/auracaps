<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text & Gradient Compositor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.8/browser/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi-filters@4.2.0/dist/pixi-filters.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-color: #2a2a2a;
            --accent: #007bff;
            --text-color: #eee;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 40px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 40px;
        }

        h2 { margin-top: 0; font-weight: 300; letter-spacing: 1px; color: #888; font-size: 16px; text-transform: uppercase; margin-bottom: 15px; width: 100%; text-align: left; border-bottom: 1px solid #444; padding-bottom: 10px;}

        .section {
            background-color: var(--panel-color);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 840px; 
            box-sizing: border-box;
        }

        canvas {
            border: 1px solid #444;
            border-radius: 4px;
            /* Changed to transparent so we can see the internal alpha logic */
            background-color: transparent; 
            background-image: linear-gradient(45deg, #222 25%, transparent 25%), linear-gradient(-45deg, #222 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #222 75%), linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            max-width: 100%;
            height: auto;
            display: block;
        }

        .controls {
            width: 100%;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            color: #ccc;
            font-weight: 600;
        }

        .value-display {
            font-family: monospace;
            color: var(--accent);
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent);
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 14px;
        }

        input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
            accent-color: var(--accent);
        }

        #source-text-canvas, #helper-canvas { display: none; }
    </style>
</head>
<body>

    <div class="section">
        <h2>1. Text Source (PixiJS)</h2>
        <div id="pixi-container"></div>
        <div class="controls">
            <div class="control-group">
                <div class="control-header">Rotation <span id="val-rot" class="value-display">70째</span></div>
                <input type="range" id="opt-rotation" min="0" max="360" value="70">
            </div>
            <div class="control-group">
                <div class="control-header">Thickness <span id="val-thick" class="value-display">3</span></div>
                <input type="range" id="opt-thickness" min="0" max="20" value="3">
            </div>
            <div class="control-group">
                <div class="control-header">Light Intensity <span id="val-light" class="value-display">0.8</span></div>
                <input type="range" id="opt-light" min="0" max="1" step="0.1" value="0.8">
            </div>
            <div class="control-group">
                <div class="control-header">Shadow Intensity <span id="val-shadow" class="value-display">0.6</span></div>
                <input type="range" id="opt-shadow" min="0" max="1" step="0.1" value="0.6">
            </div>
        </div>
    </div>

    <div class="section">
        <h2>2. Gradient Source</h2>
        <canvas id="gradCanvas" width="800" height="400"></canvas>

        <div class="controls">
            <div class="control-group">
                <div class="control-header">Angle <span id="angleVal" class="value-display">195째</span></div>
                <input type="range" id="angle" min="0" max="360" value="207">
            </div>
            <div class="control-group">
                <div class="control-header">Attack (Delay) <span id="attackVal" class="value-display">17%</span></div>
                <input type="range" id="attack" min="0" max="95" value="13">
            </div>
            <div class="control-group">
                <div class="control-header">Curve (Softness) <span id="curveVal" class="value-display">1.2</span></div>
                <input type="range" id="curve" min="0.1" max="5.0" step="0.1" value="0.6">
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="reverse" checked>
                <label for="reverse">Reverse Gradient (Black &rarr; White)</label>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>3. Blend Result (Overlay)</h2>
        <canvas id="compositeCanvas" width="800" height="400"></canvas>
    </div>

    <div class="section">
        <h2>4. Gradient Map (Gold)</h2>
        <canvas id="goldResultCanvas" width="800" height="400"></canvas>
        <div style="font-size: 12px; color: #666; margin-top: 10px; width: 100%;">
            * Mapping brightness from #3 to the Y-axis of <code>gold.png</code> (Ignoring Transparent Pixels)
        </div>
    </div>

    <canvas id="source-text-canvas" width="800" height="400"></canvas>
    <canvas id="helper-canvas"></canvas>

<script>
    // ==========================================
    // SHARED SETTINGS
    // ==========================================
    const width = 800;
    const height = 400;

    // ==========================================
    // 1. PIXIJS TEXT SETUP
    // ==========================================
    
    const sourceTextCanvas = document.getElementById('source-text-canvas');
    const txtCtx = sourceTextCanvas.getContext('2d');
    txtCtx.font = "900 120px sans-serif";
    txtCtx.textAlign = "center";
    txtCtx.textBaseline = "middle";
    txtCtx.fillStyle = "#808080"; 
    txtCtx.fillText("PIXI BEVEL", width / 2, height / 2);

    const app = new PIXI.Application({
        width: width,
        height: height,
        // CHANGED: Removed backgroundColor, added backgroundAlpha: 0
        backgroundAlpha: 0,
        antialias: true,
        autoStart: false, 
        preserveDrawingBuffer: true
    });
    document.getElementById('pixi-container').appendChild(app.view);

    const texture = PIXI.Texture.from(sourceTextCanvas);
    const textSprite = new PIXI.Sprite(texture);
    textSprite.anchor.set(0.5);
    textSprite.x = width / 2;
    textSprite.y = height / 2;

    const bevelFilter = new PIXI.filters.BevelFilter({
        rotation: 70,
        thickness: 3,
        lightColor: 0xffffff,
        shadowColor: 0x000000,
        lightAlpha: 0.8,
        shadowAlpha: 0.6
    });

    textSprite.filters = [bevelFilter];
    app.stage.addChild(textSprite);

    // ==========================================
    // 2. GRADIENT SETUP
    // ==========================================
    const gradCanvas = document.getElementById('gradCanvas');
    const gradCtx = gradCanvas.getContext('2d');

    // ==========================================
    // 3. COMPOSITE SETUP
    // ==========================================
    const compCanvas = document.getElementById('compositeCanvas');
    const compCtx = compCanvas.getContext('2d');

    // ==========================================
    // 4. GOLD MAP SETUP
    // ==========================================
    const goldResultCanvas = document.getElementById('goldResultCanvas');
    const goldCtx = goldResultCanvas.getContext('2d');
    
    const helperCanvas = document.getElementById('helper-canvas');
    const helperCtx = helperCanvas.getContext('2d');

    let goldPaletteData = null;
    let goldHeight = 0;

    const goldImg = new Image();
    goldImg.crossOrigin = "Anonymous"; 
    goldImg.src = 'gold.png';

    goldImg.onload = () => {
        helperCanvas.width = goldImg.width;
        helperCanvas.height = goldImg.height;
        helperCtx.drawImage(goldImg, 0, 0);
        
        goldHeight = goldImg.height;
        goldPaletteData = helperCtx.getImageData(0, 0, 1, goldHeight).data;
        
        renderAll();
    };

    goldImg.onerror = () => {
        console.warn("gold.png not found. Generating fallback procedural gold gradient.");
        helperCanvas.width = 1;
        helperCanvas.height = 256;
        goldHeight = 256;
        
        const grd = helperCtx.createLinearGradient(0, 0, 0, 256);
        grd.addColorStop(0, '#4a3b00');   
        grd.addColorStop(0.3, '#b88a00'); 
        grd.addColorStop(0.5, '#ffd700'); 
        grd.addColorStop(0.6, '#ffeda0'); 
        grd.addColorStop(1, '#4a3b00');   
        
        helperCtx.fillStyle = grd;
        helperCtx.fillRect(0,0,1,256);
        goldPaletteData = helperCtx.getImageData(0, 0, 1, 256).data;
        renderAll();
    };

    // ==========================================
    // LOGIC FUNCTIONS
    // ==========================================

    function updatePixi() {
        bevelFilter.rotation = parseFloat(document.getElementById('opt-rotation').value);
        bevelFilter.thickness = parseFloat(document.getElementById('opt-thickness').value);
        bevelFilter.lightAlpha = parseFloat(document.getElementById('opt-light').value);
        bevelFilter.shadowAlpha = parseFloat(document.getElementById('opt-shadow').value);
        
        document.getElementById('val-rot').textContent = document.getElementById('opt-rotation').value + "째";
        document.getElementById('val-thick').textContent = document.getElementById('opt-thickness').value;
        document.getElementById('val-light').textContent = document.getElementById('opt-light').value;
        document.getElementById('val-shadow').textContent = document.getElementById('opt-shadow').value;

        app.render();
    }

    function updateGradient() {
        const angleVal = parseFloat(document.getElementById('angle').value);
        const attackVal = parseFloat(document.getElementById('attack').value);
        const curveVal = parseFloat(document.getElementById('curve').value);
        const isReversed = document.getElementById('reverse').checked;

        document.getElementById('angleVal').textContent = angleVal + "째";
        document.getElementById('attackVal').textContent = attackVal + "%";
        document.getElementById('curveVal').textContent = curveVal.toFixed(1);

        const attackPct = attackVal / 100;
        
        gradCtx.clearRect(0, 0, width, height);

        const angleRad = (angleVal - 90) * (Math.PI / 180);
        const cx = width / 2;
        const cy = height / 2;
        const dist = Math.sqrt(width * width + height * height);

        const x0 = cx + Math.cos(angleRad) * (dist / 2);
        const y0 = cy + Math.sin(angleRad) * (dist / 2);
        const x1 = cx - Math.cos(angleRad) * (dist / 2);
        const y1 = cy - Math.sin(angleRad) * (dist / 2);

        const gradient = gradCtx.createLinearGradient(x0, y0, x1, y1);
        const startColorStr = isReversed ? 'black' : 'white';

        gradient.addColorStop(0, startColorStr);
        if (attackPct > 0) {
            gradient.addColorStop(attackPct, startColorStr);
        }

        const steps = 20; 
        const exponent = curveVal;

        for (let i = 0; i <= steps; i++) {
            const localT = i / steps; 
            const easedT = Math.pow(localT, exponent);

            let intensity;
            if (isReversed) {
                intensity = easedT; 
            } else {
                intensity = 1 - easedT;
            }

            const c = Math.floor(255 * intensity); 
            const colorStr = `rgb(${c}, ${c}, ${c})`;

            const availableSpace = 1.0 - attackPct;
            const globalPos = attackPct + (localT * availableSpace);

            gradient.addColorStop(globalPos, colorStr);
        }

        gradCtx.fillStyle = gradient;
        gradCtx.fillRect(0, 0, width, height);
    }

    function updateComposite() {
        compCtx.clearRect(0, 0, width, height);
        
        // 1. Draw Pixi Layer (The Base)
        compCtx.globalCompositeOperation = 'source-over';
        compCtx.drawImage(app.view, 0, 0);

        // 2. Blend the Gradient on top
        compCtx.globalCompositeOperation = 'overlay';
        compCtx.drawImage(gradCanvas, 0, 0);

        // 3. NEW: Clip the result to the original text shape
        // This cuts away the gradient from the empty background areas
        compCtx.globalCompositeOperation = 'destination-in';
        compCtx.drawImage(app.view, 0, 0);

        // Reset
        compCtx.globalCompositeOperation = 'source-over';
    }

    function updateGradientMap() {
        if (!goldPaletteData) return;
        
        // Clear previous draw
        goldCtx.clearRect(0, 0, width, height);

        const srcImgData = compCtx.getImageData(0, 0, width, height);
        const srcData = srcImgData.data;

        const destImgData = goldCtx.createImageData(width, height);
        const destData = destImgData.data;

        for (let i = 0; i < srcData.length; i += 4) {
            const alpha = srcData[i+3];

            // CHANGED: If alpha is low (transparent), skip or paint black
            if (alpha < 10) {
                // Keep it transparent (0,0,0,0) or make it black (0,0,0,255)
                // Since user asked for "Black", but we are in a web context,
                // transparency is usually preferred so it sits on the page background.
                // We leave it as 0 (transparent) here.
                destData[i] = 0;
                destData[i+1] = 0;
                destData[i+2] = 0;
                destData[i+3] = 0; 
                continue;
            }

            const r = srcData[i];
            const g = srcData[i+1];
            const b = srcData[i+2];

            const luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;

            let mapIndex = Math.floor((luma / 255) * (goldHeight - 1));
            
            if (mapIndex < 0) mapIndex = 0;
            if (mapIndex > goldHeight - 1) mapIndex = goldHeight - 1;

            const paletteIdx = mapIndex * 4;

            destData[i]     = goldPaletteData[paletteIdx];     // R
            destData[i + 1] = goldPaletteData[paletteIdx + 1]; // G
            destData[i + 2] = goldPaletteData[paletteIdx + 2]; // B
            
            // Use the original alpha from the source so edges look smooth
            destData[i + 3] = alpha; 
        }

        goldCtx.putImageData(destImgData, 0, 0);
    }

    function renderAll() {
        updatePixi();
        updateGradient();
        updateComposite();
        updateGradientMap(); 
    }

    // ==========================================
    // LISTENERS
    // ==========================================
    
    document.getElementById('opt-rotation').addEventListener('input', renderAll);
    document.getElementById('opt-thickness').addEventListener('input', renderAll);
    document.getElementById('opt-light').addEventListener('input', renderAll);
    document.getElementById('opt-shadow').addEventListener('input', renderAll);

    document.getElementById('angle').addEventListener('input', renderAll);
    document.getElementById('attack').addEventListener('input', renderAll);
    document.getElementById('curve').addEventListener('input', renderAll);
    document.getElementById('reverse').addEventListener('change', renderAll);

    setTimeout(renderAll, 100);

</script>
</body>
</html>