<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Epic Fractal Shader</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 u_resolution;
        uniform float u_time;

        // Cosine based palette, 4 vec3 params
        vec3 palette( float t ) {
            vec3 a = vec3(0.5, 0.5, 0.5);
            vec3 b = vec3(0.5, 0.5, 0.5);
            vec3 c = vec3(1.0, 1.0, 1.0);
            vec3 d = vec3(0.263,0.416,0.557); // Blue/Gold/Pink mix
            return a + b*cos( 6.28318*(c*t+d) );
        }

        void main() {
            // Normalize coordinates to center (0,0) and correct aspect ratio
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;
            vec2 uv0 = uv; // Keep track of original coordinates
            
            vec3 finalColor = vec3(0.0);
            
            // Iterate to create fractal layers
            for (float i = 0.0; i < 4.0; i++) {
                
                // Space folding: splits the screen into repeating patterns
                uv = fract(uv * 1.5) - 0.5;

                // Distance function
                float d = length(uv) * exp(-length(uv0));

                // Create color based on distance and time
                vec3 col = palette(length(uv0) + i*.4 + u_time*.4);

                // Create the glowing rings
                d = sin(d*8. + u_time)/8.;
                d = abs(d);

                // Inverse glow logic (closer to 0 = brighter)
                d = pow(0.01 / d, 1.2);

                finalColor += col * d;
            }
            
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) { alert('WebGL not supported'); }

        // Compile Shader Function
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Setup Program
        const vertexSrc = document.getElementById('vertex-shader').text;
        const fragmentSrc = document.getElementById('fragment-shader').text;
        
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSrc);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Define a full-screen quad (2 triangles)
        const vertices = new Float32Array([
            -1.0, -1.0,
             1.0, -1.0,
            -1.0,  1.0,
            -1.0,  1.0,
             1.0, -1.0,
             1.0,  1.0
        ]);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // Uniform Locations
        const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
        const timeLocation = gl.getUniformLocation(program, "u_time");

        // Resize Handler
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Render Loop
        function render(time) {
            time *= 0.001; // Convert to seconds
            gl.uniform1f(timeLocation, time);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>