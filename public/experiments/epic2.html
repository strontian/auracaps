<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Rectangular Water Puddle Shader</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 u_resolution;
        uniform float u_time;

        // --- Signed Distance Function for a Box ---
        // p = current coordinate, b = box dimensions (half-width, half-height)
        float sdBox( in vec2 p, in vec2 b ) {
            vec2 d = abs(p)-b;
            return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
        }

        // --- Fake Sky/Environment Pattern ---
        // Generates a sunset-like gradient with some pseudo-clouds
        vec3 getEnvironment(vec2 uv) {
            float t = u_time * 0.1;
            // Create drifting "cloud" layers using sin/cos
            float cloud1 = sin(uv.x * 3.0 + t) * sin(uv.y * 2.5 - t*1.5);
            float cloud2 = sin(uv.x * 6.0 - t*0.8) * sin(uv.y * 5.0 + t*0.2);
            float clouds = smoothstep(-0.5, 1.0, cloud1 + cloud2);
            
            // Base sky gradient colors
            vec3 deepBlue = vec3(0.05, 0.1, 0.3);
            vec3 sunsetOrange = vec3(0.9, 0.4, 0.1);
            vec3 brightYellow = vec3(1.0, 0.8, 0.3);

            // Mix based on vertical position (y)
            vec3 sky = mix(sunsetOrange, deepBlue, uv.y + 0.5);
            sky = mix(sky, brightYellow, clouds * 0.5); // Add bright cloud edges
            return sky;
        }

        // --- Ripple Distortion Function ---
        // Combines multiple sine waves traveling in different directions
        vec2 getRipples(vec2 uv) {
            float t = u_time;
            vec2 wave1 = vec2(sin(uv.y * 5.0 + t * 1.1), cos(uv.x * 5.0 + t * 1.3));
            vec2 wave2 = vec2(sin(uv.x * 8.0 - t * 0.7), cos(uv.y * 9.0 - t * 1.5));
            vec2 wave3 = vec2(sin(uv.y * 15.0 + t * 2.0), cos(uv.x * 15.0 + t * 2.5));
            
            // Combine them. The multiplier determines ripple strength.
            return (wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.1) * 0.03;
        }

        void main() {
            // Normalized pixel coordinates (from -1 to 1 on Y axis)
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;
            
            // --- 1. Define Shape ---
            // Define box dimensions (wider than tall)
            vec2 boxDim = vec2(0.6, 0.35);
            // Calculate distance to the box edge
            float boxDist = sdBox(uv, boxDim);

            // Create a soft mask for the puddle interior
            // smoothstep creates a slight blur at the edge instead of a hard pixel cut
            float puddleMask = 1.0 - smoothstep(0.0, 0.02, boxDist);

            // --- 2. Calculate Water Surface ---
            vec3 finalColor = vec3(0.0);

            if (puddleMask > 0.0) {
                // We are inside the puddle area.
                
                // Calculate distortion based on ripples
                vec2 distortion = getRipples(uv);
                
                // Sample the "sky" environment using distorted UVs.
                // We add uv * 0.2 to the sample to make the reflection look "deeper"
                vec3 reflection = getEnvironment(uv * 0.5 + distortion + vec2(0.0, u_time*0.02));
                
                // Murky water base color (dark greenish-brown)
                vec3 murkyBase = vec3(0.05, 0.07, 0.02);
                
                // Mix reflection on top of murky base based on ripple height
                // The length(distortion) gives a sense of wave peaks and troughs
                finalColor = mix(murkyBase, reflection, 0.6 + length(distortion)*10.0);
                
                // Add a bright rim/meniscus at the very edge using the SDF
                float rim = smoothstep(0.02, 0.0, abs(boxDist + 0.01));
                finalColor += vec3(0.8, 0.9, 1.0) * rim * 0.5;
                
            } else {
                // --- 3. The Ground Outside ---
                // Simple asphalt noise
                float noise = sin(uv.x*100.0)*sin(uv.y*100.0) * 0.05 + 
                              sin(uv.x*200.0)*sin(uv.y*200.0) * 0.02;
                vec3 groundCol = vec3(0.15, 0.15, 0.17) + noise;
                
                // Darken the ground right next to the puddle (wet pavement look)
                float wetEdge = smoothstep(0.0, 0.2, boxDist);
                finalColor = groundCol * mix(0.5, 1.0, wetEdge);
            }

            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) { alert('WebGL not supported'); }
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            } return shader;
        }
        const vertexSrc = document.getElementById('vertex-shader').text;
        const fragmentSrc = document.getElementById('fragment-shader').text;
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSrc);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);
        const vertices = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        const positionLocation = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
        const timeLocation = gl.getUniformLocation(program, "u_time");
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();
        function render(time) {
            time *= 0.001;
            gl.uniform1f(timeLocation, time);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>